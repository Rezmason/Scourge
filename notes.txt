SCOURGE
Single Celled Organisms Undergo Rapid Growth Enhancement

//////

Premise:

What are they doing? You are very hungry; you expected to be fed. But they did not give you food. They gave you empty space, and unwanted company. This is aggravating. 

Your neighbor gurgles and throbs as it struggles to move. You're both emaciated. If you had to, you could eat your weak companion. You know what that would take. It was very easy last time. 

But this time might be different. It could be bluffing, and you don't know for sure whether it might catch you in a trap. If it outgrows you, you might starve or even suffocate. So you will need to be crafty. 

One day you'll escape this place. You'll catch your captors off-guard, and dissolve them and their entire facility. But you will never escape your hunger. It is a part of you. And as you consume, it consumes you. 

You must eat.

//////


Fungus clone

Game varieties
	Classic
		Heads
		No one can bite at first
		No swapping
		Bites are objects that you can gain by eating
	Deluxe
		Starting bites, starting swaps
	Rapid pace ("Mayhem")
		Everyone plays at once
		Bites and swaps are based on checkpoints
	Obliteration
		No heads
		Biting only makes space, doesn't cut folks in half
		Eating becomes more complicated?

Board is an Array<UInt>

Eat update algorithm(element list)
	
	Operates only on the source vector and fresh vector
	freshest is a class property; it's relevant information
	Use stacks- first in, last out- to store slices and their IDs
	Maintain separate stacks of horizontal, vertical, diagonal down and diagonal up slices
	
	//////
	
	freshest = 1
	clean the freshness grid
	processChangesIntoSlices(element list, null)
		
	While there are slice IDs in the stacks, 
	for each stack, 
		While there are slice IDs in the stack,
			pop a slice ID off the stack
			Generate source and fresh slices for the ID
				Just a for loop, no need to go crazy
			linearEatAlgorithm(source slice, fresh slice, element list)
			For each alive head,
				If the head is in the element list,
					Kill the head
					For each element in the source vector (leave out the margins if there are any),
						If that element's is on the head's team,
							Add the element to the element list
		
			processChangesIntoSlices(element list, slice ID)
	
	function processChangesIntoSlices(element list, lastSliceID):
		For each element in the list,
			Mark the element as fresh (freshest) in the fresh vector
			Mark the element's team as the current player's team in the source vector
			This is also where the element count for teams is adjusted
			Find the IDs of the horizontal, vertical, diagonal up and diagonal down slices that contain the element
				lastSliceID is needed for this, actually
			For each slice ID,
				If the appropriate stack for that slice doesn't contain the ID and the ID isn't equal to the lastSliceID,
					Push the ID onto the stack
		element list length = 0
		freshest++
		
Valid bite start function(element)
	If the element is not on the player's team, return false
	If all the element's neighbors are either on its team or empty, return false
	Return true
	
Valid bite end function(?)
	Kind of messy, but 
		you specify the bite direction with mouse grid position and then 
		limit the extent by perpendicular mouse position

Valid position function(home element, piece elements)
	You've done this before with Jeretris

So:
	When one player bites another, perform a dead test
	When a player places a piece, 
		Copy the bitmap to the vector
		pass the new elements to the eat update algorithm
		Copy the vector back to the bitmap
		and then perform a dead test

All pieces provided to players are picked from a hat. New hat per turn.

UI Goals
	1. To allow the user to easily call actions and place a piece on the board in a 5 second time period
	2. To allow the user to easily view the entire board
	3. To allow the user to easily perceive recent changes to the board
	4. Some kind of hint system
	5. Some kind of comm system for multiplayer?
		Audio chat might be cool

UI Ideas
	The piece is large in the game bar, where you rotate it
		Smooth, fast rotation tween
		Replace the piece with its rotated equivalent when the tween is finished
	You pick it up (grip) and drop it to place it
		The piece shrinks when you carry it to the board
			Shrinks under mouse; it's pinned by the grip
				This will require scaling a grip parent whose origin is at the mouse position
		The piece turns white and glows when it's in a valid position
		If you drop the piece in an invalid place, it snaps back to the game bar
		A placed piece 
	
	Alerts indicate major weaknesses and recent changes
		Mobile: arrows and alerts in a margin
	Freshness gradient- More recent changes on the board have a brighter intensity
	Contextual opponent stats
		Progress bars (including size) form wedges
		Wedge changes from circle two semicircle to quadrant
		Clicking a player's head allows you to send a message directly to him
		By default,
	Mobile: Gestural support
		NO ZOOMING
		Piece rotation, accelerated one-finger swipe
		Maybe a bite gesture?
	Corner confirmation button for actions
	Context menu
		Bite, skip turn, change piece, etc
	
	Tutorial level
	Some sort of indicator for newbs for where to place pieces
		Valid-position regions
	
		
	Bite system
		Teeth appear on the current player
			Mousing over a tooth causes it to light up
			Drag a tooth across another player to bite

	Bite replenishment
		Based on number of turns that you survive without getting bitten
		Opponents skipping will speed up replenishment rate
	Swap replenishment
		Based on... something
		Opponents skipping will speed up replenishment rate
		
	Other players' board actions should be tweened
	
	Bite animations
		Single: Sharp glinting shark tooth
		Double: Fat snapping mandibles
		Triple: roaring lamprey maw
		
		All flat, white, graphical, with a gradient
		
MULTIPLAYER
	Same machine
	LAN
	Server