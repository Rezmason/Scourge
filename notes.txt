SCOURGE
Single Celled Organisms Undergo Rapid Growth Enhancement

//////

Premise:

What are they up to? You are very hungry; you expected to be fed. But they did not give you food. They gave you empty space, and unwanted company. This is aggravating. 

Your neighbor gurgles and throbs as it struggles to move. You're both emaciated. If you had to, you could kill and eat your weak companion. You know what that would take. It was very easy last time. 

But each fight is a little different. Your enemy may not be as weak as it seems. If you underestimate it, it could make a meal out of you. If it outgrows you, you might starve or even suffocate. It might simply gain the upper hand. So you will need to be crafty. 

One day you'll escape this terrible place. You'll catch your captors off-guard, and dissolve them and their entire facility. But you will never escape your hunger. It is a part of you. And as you consume, it consumes you. 

You must eat.

//////


Fungus clone

Game varieties
	Classic
		Heads
		No one can bite at first
		No swapping
		Bites are objects that you can gain by eating
	Deluxe
		Starting bites, starting swaps
	Rapid pace ("Mayhem")
		Everyone plays at once
		Bites and swaps are based on checkpoints
	Obliteration
		No heads
		Biting only makes space, doesn't cut folks in half
		Eating becomes more complicated?

Board is an Array<UInt>

Eat update algorithm(element list)
	
	Operates only on the source vector and fresh vector
	freshest is a class property; it's relevant information
	Use stacks- first in, last out- to store slices and their IDs
	Maintain separate stacks of horizontal, vertical, diagonal down and diagonal up slices
	
	//////
	
	freshest = 1
	clean the freshness grid
	processChangesIntoSlices(element list, null)
		
	While there are slice IDs in the stacks, 
	for each stack, 
		While there are slice IDs in the stack,
			pop a slice ID off the stack
			Generate source and fresh slices for the ID
				Just a for loop, no need to go crazy
			linearEatAlgorithm(source slice, fresh slice, element list)
			For each alive head,
				If the head is in the element list,
					Kill the head
					For each element in the source vector (leave out the margins if there are any),
						If that element's is on the head's team,
							Add the element to the element list
		
			processChangesIntoSlices(element list, slice ID)
	
	function processChangesIntoSlices(element list, lastSliceID):
		For each element in the list,
			Mark the element as fresh (freshest) in the fresh vector
			Mark the element's team as the current player's team in the source vector
			This is also where the element count for teams is adjusted
			Find the IDs of the horizontal, vertical, diagonal up and diagonal down slices that contain the element
				lastSliceID is needed for this, actually
			For each slice ID,
				If the appropriate stack for that slice doesn't contain the ID and the ID isn't equal to the lastSliceID,
					Push the ID onto the stack
		element list length = 0
		freshest++
		
Valid bite start function(element)
	If the element is not on the player's team, return false
	If all the element's neighbors are either on its team or empty, return false
	Return true
	
Valid bite end function(?)
	Kind of messy, but 
		you specify the bite direction with mouse grid position and then 
		limit the extent by perpendicular mouse position

Valid position function(home element, piece elements)
	You've done this before with Jeretris

So:
	When one player bites another, perform a dead test
	When a player places a piece, 
		Copy the bitmap to the vector
		pass the new elements to the eat update algorithm
		Copy the vector back to the bitmap
		and then perform a dead test

All pieces provided to players are picked from a hat. New hat per turn.

UI Goals
	1. To allow the user to easily call actions and place a piece on the board in a 5 second time period
	2. To allow the user to easily view the entire board
	3. To allow the user to easily perceive recent changes to the board
	4. Some kind of hint system
	5. Some kind of comm system for multiplayer?
		Audio chat might be cool

UI Ideas
	The piece is large in the game bar, where you rotate it
		Smooth, fast rotation tween
		Replace the piece with its rotated equivalent when the tween is finished
	You pick it up (grip) and drop it to place it
		The piece shrinks when you carry it to the board
			Shrinks under mouse; it's pinned by the grip
				This will require scaling a grip parent whose origin is at the mouse position
		The piece turns white and glows when it's in a valid position
		If you drop the piece in an invalid place, it snaps back to the game bar
		A placed piece 
	
	Alerts indicate major weaknesses and recent changes
		Mobile: arrows and alerts in a margin
	Freshness gradient- More recent changes on the board have a brighter intensity
	Contextual opponent stats
		Progress bars (including size) form wedges
		Wedge changes from circle two semicircle to quadrant
		Clicking a player's head allows you to send a message directly to him
		By default,
	Mobile: Gestural support
		NO ZOOMING
		Piece rotation, accelerated one-finger swipe
		Maybe a bite gesture?
	Corner confirmation button for actions
	Context menu
		Bite, skip turn, change piece, etc
	
	Tutorial level
	Some sort of indicator for newbs for where to place pieces
		Valid-position regions
	
		
	Bite system
		Teeth appear on the current player
			Mousing over a tooth causes it to light up
			Drag a tooth across another player to bite

	Bite replenishment
		Based on number of turns that you survive without getting bitten
		Opponents skipping will speed up replenishment rate
	Swap replenishment
		Based on... something
		Opponents skipping will speed up replenishment rate
		
	Other players' board actions should be tweened
	
	Bite animations
		Single: Sharp glinting shark tooth
		Double: Fat snapping mandibles
		Triple: roaring lamprey maw
		
		All flat, white, graphical, with a gradient
		
MULTIPLAYER
	Same machine (PC)
	LAN (PC)
	Server (PC, mobile)
	P2P / Game Thing (mobile)
	
Player data is presented when the user hovers over a given player
	Stats
		Hex logo
		Name
		Bite icon and number of bites
		In-game growth graph
		Community rank graph
		
		
Ad placement
	sponsorship
		If a player wears a logo and wins, he gets a promo code from the sponsor
	last words
		Before a player dies, he gets to say whatever he wants. OR he can force everyone to watch an ad for 15 seconds.
	
	
Multiplayer authentication
	Server passes each client a separate key
		Client passes key back to authenticate each user action
		
		
Scourge game architecture needs to be made immutable
	Right now it's basically rules operating on a single state
	Needs to accept a state and spit out another

Advanced Scourge game functions

findPlayerEdges
	Returns a list of indices that are adjacent to a player

evaluatePiece

Ideas for powerups
	Toxic - kills all adjacent cells
	Hearty - when eaten, only the outer cells will actually change
	Venom - a bite paralyzes part of an enemy, so that they can't bite or place a piece there.
	Stomp - player can place pieces on top of other players


JavaScript, non-EaselJS ideas
	Glows and shadows are pretty much the same
	Figure out how to work with Klingemann's stackblur and alpha channels
	CSS box shadows allow for inset; maybe I should div some stuff
	Translate SVG somehow into shapes
		http://code.google.com/p/canvg/source/browse/trunk/canvg.js
	Blend modes??
		Look on Stack Overflow for that guy's library
		
	WHAT THE FUCK AM I DOING
		
		
	function importCanvas(sourceCanvas, targetSVG) {
		var image = sourceCanvas.toDataURL("image/png");
		var svgimg = document.createElementNS("http://www.w3.org/2000/svg", "image");
		svgimg.setAttributeNS("http://www.w3.org/1999/xlink", 'xlink:href', image);
		targetSVG.appendChild(svgimg);
	}
	
	<foreignobject /> tag in SVG lets you stick canvases inside