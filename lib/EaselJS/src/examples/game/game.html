<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>EaselJS Example: Building a game</title>

<link href="../styles.css" rel="stylesheet" type="text/css" />

<!-- Import EaselJS Framework -->
<script src="../../com/gskinner/utils/UID.js"></script>
<script src="../../com/gskinner/display/SpriteSheet.js"></script>
<script src="../../com/gskinner/display/Shadow.js"></script>
<script src="../../com/gskinner/display/DisplayObject.js"></script>
<script src="../../com/gskinner/display/Container.js"></script>
<script src="../../com/gskinner/display/Stage.js"></script>
<script src="../../com/gskinner/display/Shape.js"></script>
<script src="../../com/gskinner/utils/Tick.js"></script>
<!-- End EaselJS Imports -->

<!-- Game script below -->
<script src="SpaceRock.js"></script>
<script src="Ship.js"></script>
<script>

var DIFFICULTY = 2;			//how fast the game gets mor difficult
var ROCK_TIME = 110;		//aprox tick count untill a new asteroid gets introduced
var SUB_ROCK_COUNT = 4;		//how many small rocks to make on rock death
var BULLET_TIME = 5;		//ticks between bullets

var TURN_FACTOR = 7;		//how far the ship turns per frame
var BULLET_SPEED = 17;		//how fast the bullets move

var KEYCODE_SPACE = 32;		//usefull keycode
var KEYCODE_UP = 38;		//usefull keycode
var KEYCODE_LEFT = 37;		//usefull keycode
var KEYCODE_RIGHT = 39;		//usefull keycode
var KEYCODE_W = 87;			//usefull keycode
var KEYCODE_A = 65;			//usefull keycode
var KEYCODE_D = 68;			//usefull keycode

var shootHeld;			//is the user holding a shoot command
var lfHeld;				//is the user holding a turn left command
var rtHeld;				//is the user holding a turn right command
var fwdHeld;			//is the user holding a forward command

var timeToRock;			//difficulty adjusted version of ROCK_TIME
var nextRock;			//ticks left untill a new space rock arrives
var nextBullet;			//ticks left untill the next shot is fired

var rockBelt;			//space rock array
var bulletStream;		//bullet array

var canvas;		//Main canvas
var stage;		//Main display stage

var ship;		//the actual ship
var alive;		//wheter the player is alive


//register key functions
document.onkeydown = handleKeyDown;
document.onkeyup = handleKeyUp;

function init() {
	//associate the canvas with the stage
	canvas = document.getElementById("testCanvas");
	stage = new Stage(canvas);
	watchRestart();
}

function watchRestart() {
	//watch for clicks
	var field = document.getElementById("welcome");
	field.onclick = handleClick;
	canvas.onclick = handleClick;
}

function handleClick() {
	//prevent re clicks and hide text
	canvas.onclick = null;
	var field = document.getElementById("welcome");
	field.onclick = null;
	field.style.display = 'none';
	
	restart();
}

//reset all game logic
function restart() {
	//hide anything on stage and show the score
	stage.removeAllChildren();
	var field = document.getElementById("scoreField");
	field.innerHTML = (0).toString();
	
	//new arrays to dump old data
	rockBelt = new Array();
	bulletStream = new Array();
	
	//create the player
	alive = true;
	ship = new Ship();
	ship.x = canvas.width / 2;
	ship.y = canvas.height / 2;
	
	//log time untill values
	timeToRock = ROCK_TIME;
	nextRock = 0;
	nextBullet = 0;
	
	//reset key presses
	shootHeld =	false;
	lfHeld =	false;
	rtHeld =	false;
	fwdHeld =	false;
	dnHeld =	false;
	
	//ensure stage is blank and add the ship
	stage.clear();
	stage.addChild(ship);
	
	//start game timer
	Tick.addListener(window);
}

function tick() {
	//handle firing
	if(nextBullet <= 0) {
		if(alive && shootHeld){
			nextBullet = BULLET_TIME;
			fireBullet();
		}
	} else {
		nextBullet--;
	}
	
	//handle turning
	if(alive && lfHeld){
		ship.rotation -= TURN_FACTOR;
	} else if(alive && rtHeld) {
		ship.rotation += TURN_FACTOR;
	}
	
	//handle thrust
	if(alive && fwdHeld){
		ship.accelerate();
	}
	
	//handle new spaceRocks
	if(nextRock <= 0) {
		if(alive){
			timeToRock -= DIFFICULTY;	//reduce spaceRock spacing slowly to increase difficulty with time
			var index = getSpaceRock(SpaceRock.LRG_ROCK);
			rockBelt[index].floatOnScreen(canvas.width, canvas.height);
			nextRock = timeToRock + timeToRock*Math.random();
		}
	} else {
		nextRock--;
	}
	
	//handle ship looping
	if(alive && outOfBounds(ship, ship.bounds)) {
		placeInBounds(ship, ship.bounds);
	}
	
	//handle bullet movement and looping
	for(bullet in bulletStream) {
		var o = bulletStream[bullet];
		if(!o) { continue; }
		if(outOfBounds(o, ship.bounds)) {
			placeInBounds(o, ship.bounds);
		}
		o.x += Math.sin(o.rotation*(Math.PI/-180))*BULLET_SPEED;
		o.y += Math.cos(o.rotation*(Math.PI/-180))*BULLET_SPEED;
	}
	
	//handle spaceRocks (nested in one loop to prevent excess loops)
	for(spaceRock in rockBelt) {
		var o = rockBelt[spaceRock];
		if(!o) { continue; }
		
		//handle spaceRock movement and looping
		if(outOfBounds(o, o.bounds)) {
			placeInBounds(o, o.bounds);
		}
		o.tick();
		
		
		//handle spaceRock ship collisions
		if(alive && o.hitRadius(ship.x, ship.y, ship.hit)) {
			alive = false;
			
			stage.removeChild(ship);
			var field = document.getElementById("welcome");
			field.innerHTML = "You're dead: <br /> Click to play again";
			field.style.display = 'block';
			watchRestart();
			
			continue;
		}
		
		//handle spaceRock bullet collisions
		for(bullet in bulletStream) {
			var p = bulletStream[bullet];
			if(!p) { continue; }
			
			if(o.hitPoint(p.x, p.y)) {
				var newSize;
				switch(o.size) {
					case SpaceRock.LRG_ROCK: newSize = SpaceRock.MED_ROCK;
						break;
					case SpaceRock.MED_ROCK: newSize = SpaceRock.SML_ROCK;
						break;
					case SpaceRock.SML_ROCK: newSize = 0;
						break;
				}
				
				//score
				if(alive) {
					addScore(o.score);
				}
				
				//create more
				if(newSize > 0) {
					var i;
					var index;
					var offSet;
					
					for(i=0; i < SUB_ROCK_COUNT; i++){
						index = getSpaceRock(newSize);
						offSet = (Math.random() * o.size*2) - o.size;
						rockBelt[index].x = o.x + offSet;
						rockBelt[index].y = o.y + offSet;
					}
				}
				
				//remove
				stage.removeChild(o);
				rockBelt[spaceRock] = null;
				
				stage.removeChild(p);
				bulletStream[bullet] = null;
			}
		}
	}
	
	//call sub ticks
	ship.tick();
	stage.tick();
}

function outOfBounds(o, bounds) {
	//is it visibly off screen
	return o.x < bounds*-2 || o.y < bounds*-2 || o.x > canvas.width+bounds*2 || o.y > canvas.height+bounds*2;
}

function placeInBounds(o, bounds) {
	//if its visual bounds are entirely off screen place it off screen on the other side
	if(o.x > canvas.width+bounds*2) {
		o.x = bounds*-2;
	} else if(o.x < bounds*-2) {
		o.x = canvas.width+bounds*2;
	}
	
	//if its visual bounds are entirely off screen place it off screen on the other side
	if(o.y > canvas.height+bounds*2) {
		o.y = bounds*-2;
	} else if(o.y < bounds*-2) {
		o.y = canvas.height+bounds*2;
	}
}

function fireBullet() {
	//create the bullet
	var o = bulletStream[getBullet()];
	o.x = ship.x;
	o.y = ship.y;
	o.rotation = ship.rotation;
	
	//draw the bullet
	o.setStrokeStyle("#FFFFFF");
	o.beginPath();
	o.moveTo(-1, 0);
	o.lineTo(1, 0);
	o.stroke();
}
	
function getSpaceRock(size) {
	var i = 0;
	var len = rockBelt.length;
	
	//reuse array locations, simple pooling approach
	while(i < len){
		if(!rockBelt[i]) {
			break;
		} else {
			i++;
		}
	}
	
	rockBelt[i] = new SpaceRock(size);
	stage.addChild(rockBelt[i]);
	return i;
}

function getBullet() {
	var i = 0;
	var len = bulletStream.length;
	
	//reuse array locations, simple pooling approach
	while(i < len){
		if(!bulletStream[i]) {
			break;
		} else {
			i++;
		}
	}
	
	bulletStream[i] = new Shape();
	stage.addChild(bulletStream[i]);
	return i;
}

//allow for WASD and arrow control scheme
function handleKeyDown(e) {
	//cross browser issues exist
	if(!e){ var e = window.event; }
	switch(e.keyCode) {
		case KEYCODE_SPACE:	shootHeld = true; break;
		case KEYCODE_A:;
		case KEYCODE_LEFT:	lfHeld = true; break;
		case KEYCODE_D:;
		case KEYCODE_RIGHT: rtHeld = true; break;
		case KEYCODE_W:;
		case KEYCODE_UP:	fwdHeld = true; break;
	}
}

function handleKeyUp(e) {
	//cross browser issues exist
	if(!e){ var e = window.event; }
	switch(e.keyCode) {
		case KEYCODE_SPACE:	shootHeld = false; break;
		case KEYCODE_A:;
		case KEYCODE_LEFT:	lfHeld = false; break;
		case KEYCODE_D:;
		case KEYCODE_RIGHT: rtHeld = false; break;
		case KEYCODE_W:;
		case KEYCODE_UP:	fwdHeld = false; break;
	}
}

function addScore(value) {
	//trust the field will have a number and add the score
	var field = document.getElementById("scoreField");
	field.innerHTML = (Number(field.innerHTML) + Number(value)).toString();
}

</script>
</head>
	
<body onload="init();">
	<div class="description">
	Demo showing a simple game using vector Shapes and a Container. Arrow keys to steer, space to shoot.<br/>
	</div>
	<div class="canvasHolder" style="background-color:#000000; height:600px;">
		<canvas style="position:absolute; float:left" id="testCanvas" width="980px" height="600px"></canvas>
		<div id="scoreField" style="position:relative; font-family:Arial, Helvetica, sans-serif; color:#FFFFFF; top: 15px; left: 20px; text-align: left; width: 100px"></div>
		<div id="welcome" style="position:relative; font-size: 24px; font-family:Arial, Helvetica, sans-serif; color:#FFFFFF; top: 270px; left: 16px; text-align: center; width: 980px">
		Welcome:<br /> Click to play
		</div>
	</div>
</body>
</html>
