Style the tokens differently
    Style type should depend on token type
        PLAIN_TEXT style is typed to Style
        SHORTCUT style is typed to ButtonStyle
            Wire it up to a helper.bind(token) function
        CAPSULE style is typed to InputStyle
            Rely on InputStyle to do its work; just set its state

Token clicking ought to work too
    Clicking on an input token should move the carets
    Shortcuts
        UIText broadcasts clicks to interpreter, which routes them to the proper command
    Buttons should become non-interactive when they enter the main text
        Replace button styles with their up states
        Replace input styles similarly

Support input types
    RotationNotation
        ~/[yuio]*/i
    NodeCode
        ~/[\da-f]*/i
    CrawlScrawl
        ~/[qweasdzxc]*/i

Implement all non-play text commands

Human players, GUISystem
    Implement all text commands

Move the logic into a Worker
Get referee to handle situations where a player takes too long to sync or move
    "Player has been replaced with a bot of Level N"

Depth of field in frag shader?
    Already got the vZ and deriv

NodeView and BoardBody

    Throb

        Now, stop the pools from looping
            Drive the heartbeats by a timer

    Basics
        handleBoardUpdate function
            Each node view checks for a change in board state
                Includes connectivity pass
            (Narratological cues would happen here, like stress level and text unlock)
        handleUIUpdate function
            Interpret UI state
            Check each UI for a change in state
        updateAnimation
            (for propagating waves along slimes' bodies)
        Dialer animation
            Dispatches keyboard interactions
    Orchestrate changes in the game
        Test that board state is properly handled

"Frame"
    White box drawing characters with piece in the middle
    Symbols on the corners
        H-flip, V-flip, C-rot, CC-rot
        Animation would be nice
    Swipeable

Implement noneuclidean walking and running
    add() function should create heading data
    walk() and run() functions should operate on heading data
    heading data should be available after a walk
    Turtle?

Scroll indicator in UIBody

It'd be fun to make a branch that renders glyphs as points

Finalize ROPES classes

Save states and save testing
    If the code for a rule changes, the games that used earlier versions of that rule are kind of botched
    How do other games handle this?
    http://www.altdevblogaday.com/2011/07/09/synchronous-rts-engines-and-a-tale-of-desyncs

GDC articles
    http://www.gamasutra.com/view/news/189266/The_technique_LucasArts_used_to_design_its_classic_adventure_games.php
    http://www.gamasutra.com/view/news/189251/7_practical_tips_for_making_a_moral_game.php
    http://www.gamasutra.com/view/news/189345/How_to_use_live_events_to_promote_your_game.php
    http://www.gamasutra.com/view/news/189353/Designing_without_a_pitch__An_FTL_postmortem.php

Hey, this game is a Roguelike!
    Figure out what solutions they have to UI challenges

Make renderer cross-platform (as in, test it on several devices)
    Oh boy...

Checksums

Rewrite the eat rule recursion config property to be an Int of depth
    Rather than being recursive or not recursive at all, let the user specify how many recursive steps to take

And then SPEED EVERYTHING UP
    Use timing output to find the bottlenecks
    Lambda.has is expensive - switch to using tables of ids
    Store useful information, like edges, distance and connectedness values
    Rules that take advantage of these values would expand a graph from an affected square
    Just make sure to update this information when it changes
    Take advantage of linked lists for storing sets of nodes
    Also, haxe.List might be better than Array in some situations

ExternalPlayer
Turn durations

Coarse evaluation
    Number of nodes (filled and enclosed)
    Attribute count (bites and swaps) times attribute range
    Percentage of nodes that are outer edges!
    Number of nodes


A.I. thoughts
    Shannon Type B
    Identify and prune the moves that are just fucking stupid
    Sort by coarse evaluation
    Only consider the top N possibilities
    Alpha-Beta pruning
    Is this even possible?
    Fretting
    aka "Permanent brain"
    Players technically aren't limited to their turn in order to evaluate the board


Later

    Package the Rule Oriented Paradigm Entity System so other people can use it

        'Tie down your game design'
        'Constraints can be a good thing'

        Create tic tac toe example for ROPES
        Create readme and license files for ROPES
        Migrate tests to tic tac toe
        Move ROPES to a haxe lib

    Level Editing - Just a bunch of demiurgic rules

    Lazy board - only represents nodes near players, expands when necessary

    Destination goal rule
    Allow goal rules to apply to specific players

Metaballs should be simpler now
    Particles are added-together blurcles
    Screen-size quad gets textured and shaded in another pass
    Third pass renders the "real geom" and then overlays the metaballs on top

Alternative: 2D metaballs in displacement map
    Vertex shader:
        - combines displacement map with normal map to increase height (with a curve)
        - passes info to fragment shader; transition from surface to slime might be different for texture than for geom

Texture synthesis
    Dots
    Stripes
    Put them on an environmental map
    Use a shader to map the texture onto a blob! :-)

http://code.google.com/p/hxgk/

Game starts as a primer
    History of game states and commands allows player to better understand how games progress

Contact Jason Whong?
