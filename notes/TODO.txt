RefereeTest - make steps to ensure that the game is actually recovered

Node directionality don't work the way you think they work
	Consider a cube corner
		Two faces of the cube that meet can share cardinality
		But the face that connects them both cannot share cardinality with both

	Revised walking/running
		Specify your direction locally; that's your "heading"
		if the current node and the next node share their direction, keep going in your heading
		otherwise, adjust the heading by the offset represented by the current node's index in the next node's list of neighbors

	Notion of "turning"
		Depends on how you got to where you are. Heading is an important byproduct of walks that crease
		Run should accept several directions and distances

Somehow prevent the state from being modified except during chooseOption / chooseQuantumOption
	Mutability would rock


TextView

	Scale text field up
	get bounds of m char
	Convert whole font to Array<BitmapData>

	PrettyChar
		Centered billboard
		scale tween
		color transform
			tween


	Interprets commands
	Translates all other game events into human readable output

	¤ ¤ ¤ ¤ ¤ ¤ ¤ ¤  • • •
	¤             ¤  •
	¤   + + +{+}  ¤
	¤   + Ω ¬ +   ¤
	¤   + ¬ ¬ +   ¤
	¤  [+]+ +  ◊ ¤
	¤             ¤
	¤ ¤ ¤ ¤ ¤ ¤ ¤ ¤

	¬  > Ω Î @ Δ ◊ ¤ _ { } [ ] • ø

Finalize ROPES classes

Save states and save testing
	If the code for a rule changes, the games that used earlier versions of that rule are kind of botched
		How do other games handle this?

TestPlayer
HumanPlayer
RemotePlayer
MachinePlayer (local)

Checksums

Rewrite the eat rule recursion property to be an Int of depth

And then SPEED EVERYTHING UP
	Use timing output to find the bottlenecks
	Lambda.has is expensive - switch to using tables of ids
	Store useful information, like edges, distance and connectedness values
		Rules that take advantage of these values would expand a graph from an affected square
		Just make sure to update this information when it changes
	Take advantage of linked lists for storing sets of nodes
	Also, haxe.List might be better than Array in some situations

ExternalPlayer
Turn durations
	Special aspect I suppose

GameView

Coarse evaluation
	Number of nodes (filled and enclosed)
	Attribute count (bites and swaps) times attribute range
	Percentage of nodes that are outer edges!
	Number of nodes


A.I. thoughts
	Shannon Type B
		Identify and prune the moves that are just fucking stupid
			Sort by coarse evaluation
			Only consider the top N possibilities
	Alpha-Beta pruning
		Is this even possible?
	Fretting
		aka "Permanent brain"
		Players technically aren't limited to their turn in order to evaluate the board


Later

	Rule-Option Paradigm Entity System
		Create tic tac toe example for ROPES
		Create readme and license files for ROPES
		Migrate tests to tic tac toe
		Move ROPES to a haxe lib

	Maybe turn nodes into aspects
		Store their neighbors on them

	Level Editing
		Just a bunch of rules, aha

	Infinite board
		Expand board when placing a piece
		Tough?

	Destination goal rule
	Allow goal rules to apply to specific players


New UI

	Switch back to MISO font
	Data indicators

	Icons
	Color Transform

	Game board

		Slime
			Hoo boy

		Piece
			Piece Panning
		Bites
			Bite panning
		Bite tracks

		Player info
			hover for mouse
			Press for touch

	Touch mode
		Swipe gesture instead of click for auto expand
		Press instead of hover for hint
	Mouse mode
		Board doesn't zoom for chop
		No swiping at all?

Texture synthesis
	Dots
	Stripes
	Put them on an environmental map
	Use a shader to map the texture onto a blob! :-)

http://code.google.com/p/hxgk/

Game starts as a primer
	History of game states and commands allows player to better understand how games progress

Contact Jason Whong?
